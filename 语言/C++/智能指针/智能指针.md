## 智能指针（引用次数加减是原子操作，而指针拷贝不是，因此整体来说不是线程安全）

C++不允许将裸指针赋值给智能指针

#### shared_ptr

优先考虑使用make_shared构造

reset : 无参数则清空指针，有参数则指向重新赋值给指针

use_count : 返回指针数

解决问题：能够使多个读操作访问同一内存，而不必为此进行深拷贝浪费内存

存在问题：容易造成内存泄露，两个对象中分别包含彼此的shared_ptr导致无法调用析构函数

#### unique_ptr

解决了stared_ptr造成的内存泄露问题，但是不支持多个读操作访问

#### weak_ptr

配合shared_ptr使用