# 大学数据库考试纲要

# 1 第一章

## 1.1 数据管理发展阶段

* **人工管理阶段**

  特点：

  1. 不保存数据
  2. 应用程序管理数据
  3. 数据不共享，冗余度大
  4. 程序与数据不具有独立性

* **文件系统管理阶段**

  优点：

  1. 数据可以长期保存
  2. 文件系统管理数据
  3. 程序与数据之间存在一定的独立性

  缺点：

  1. 数据共享性差，冗余度大
  2. 数据独立性差。

* **数据库系统管理阶段**

  统一管理数据的专门的**软件系统**，即数据库管理系统。

* **NoSQL非结构化数据库**

  四大分类：

  1. 键值存储数据库
  2. 列存储数据库
  3. 文档型数据库
  4. 图形数据库
  
  常见NoSQL数据库：

  5. MongoDB：基于分布式文件存储的数据库
  6. HBase：一个分布式的、面向列的开源数据库
  7. Redis：是一个键值存储系统

## 1.2 数据库相关概念

* **数据和信息**

  数据是信息的载体，而信息是数据的内涵。统一信息可以有不同的数据表示形式，而同一数据也可能有不同的解释。

* **数据库**

  存放数据的仓库，是长期存储在计算机内有组织的、可共享的大量数据集合。其中的数据按照一定的数据模型组织、描述和存储。
  
  具有以下三个特点：
  
  1. 永久存储
  2. 有组织
  3. 可共享

* **数据库系统**
  
  是指引入数据库后的系统，包括数据库、数据库管理系统、应用系统和数据库管理员四部分组成。

* **数据库管理系统（DBMS）**

  DBMS是位于用户和操作系统之间的一种数据管理软件，用于管理、控制和维护数据库，方便用户使用且提供对数据的保护。

# 2 第二章

## 2.1 数据模型

数据库需要将现实中的事物抽象成能够存储进数据库的数据，即数字化，数据模型就是对现实世界的模拟和抽象，用来描述数据是如何组成存储和操作的。

将实体数字化需要经过三个阶段：现实世界、信息世界和机器世界。

数据模型应当满足以下三种条件：

1. 能比较真实地模拟现实世界
2. 数据模型容易被人所理解
3. 数据模型要能够很方便的再计算机上实现

根据数据模型应用的目的不同，分为现实世界到信息世界的**概念层数据模型**和信息世界到机器世界的**组织层数据模型**。

数据结构的组成元素包括：

1. 数据结构
2. 数据操作
3. 数据的完整约束条件

根据数据模型的不同应用层次分类：

1. **概念模型**
2. **逻辑模型**
3. 物理模型

## 2.2 概念模型

用于对信息世界的组织和建模，是现实世界到机器世界的一个中间过程，是用户和数据库设计人员进行交流的语言。因此应当具有较强的语义性和简单性。

**基本概念**：

1. 实体：现实世界相同事物或者概念的**集合**。
2. 属性：实体所具有的某一特性。
3. 码：唯一标识实体的属性集称为码。
4. 实体型：用实体名和其属性集来抽象刻画所有同类实体，称为实体型。
5. 实体集：统一类型实体的集合。
6. 联系：实体内部和实体之间的联系。

**联系**：

1. 两个实体之间的联系：
   1. 一对一联系（1 : 1）：对于实体集A中的每一个实体，在实体集B中至多有一个与之联系，反之亦然。
   2. 一对多联系（1 : n）：对于实体集A中的每一个实体，在实体集B中存在n个实体与之联系；对于实体集B中的每一个实体，在实体集A中仅有一个与之联系。
   3. 多对多联系（m : n）：对于实体集A中的每一个实体，在实体集B中存在n个实体与之联系；对于实体集B中的每一个实体，在实体集A中也有m个与之联系。
2. 两个以上实体之间的联系：
   同样有一对一（1 : 1），一对多（1 : n），多对多（m : n : p）的联系
3. 单个实体之间的联系：
   同样有一对一（1 : 1），一对多（1 : n），多对多（m : n : p）的联系

**ER方法（实体-联系方法）**：

1. 用来描述现实世界信息结构的常用方法，通常使用ER图来描述，描述结果也被称为ER模型。
2. ER图由实体、属性和联系组成：
   1. 实体：用矩形表示。
   2. 属性：用椭圆表示，主码用下划线标明，用无向线段将其与实体连接。
   3. 联系：用菱形表示，用无向线段与有关实体连接。

## 2.3 逻辑模型

必须要把概念模型转换为逻辑数据模型才能在DBMS中实现，因此逻辑模型既面向用户又面向系统。

逻辑数据模型就是一种组织数据的数据结构，是具体的DBMS支持的数据模型。

**常见的逻辑数据模型**：
1. 层次模型：
   优点是实现简单、结构清晰、数据呈现完整；缺点是不能表示两种以上实体的联系和多对多联系、插入删除复杂、查询孩子节点必须经过双亲节点。
2. 网状模型：
   优点是更直观的表现现实世界的复杂关系、具有良好的性能和存储效率；缺点是结构复杂、数据独立性差。
3. 关系模型：就是我们常说的给关系表（employee表、student表......）
   1. 优点在于与其他模型相比，关系模型具有较强数据理论根据、数据结构简单清晰、关系模型的存取路径对用户不可见，方便程序员工作，也确保了更高的数据独立性和安全性；
   2. 缺点在于由于存取路径不可见，导致对数据的查询效率低需要优化，增加了开发DBMS的负担、关系必须是规范化的（即属性是不可再分的数据项，不允许表中有表）。

## 2.4 三层结构体系结构和数据独立性

三层结构体系基于不同级别用户对数据库的认知不同，分为三层：外模式、模式（又称概念模式）、内模式。三级模式有助于**提高数据库的逻辑独立性和物理独立性**。

**三级模式结构**：
1. 外模式：也称子模式或者用户模式，是用户或应用程序员能看到的**一部分数据的逻辑结构和特征描述**。外模式一般是模式的子集，可以有多个外模式。
2. 模式：是介于内模式和外模式之间的模式，包含**所有数据的逻辑结构和特征描述**，因此只有一个概念模式。外模式都是模式的一部分体现。
3. 内模式：也称存储模式，是**所有数据的物理结构和存储结构的描述**，即数据在数据库中是以什么方式存储的。只有一个内模式。

**二级映像**：
1. 为了实现三级模式的联系和转换，DBMS在三级模式之间增加了二级映像。
2. 外模式/模式映像：定义了外模式和模式的映射关系，当模式改变时，可以通过管理员手动调整映像的方式，让外模式也不会因此随之改变，确保了数据的**逻辑独立性**。由于存在多个外模式，所以也要**存在多个**外模式/模式映像。
3. 模式/内模式映像：定义了数据的逻辑结构和存储结构的映射关系，当数据库存储结构改变时，可以通过管理员手动调整映像的方式，让模式也不会因此随之改变，确保了数据的**物理独立性**。由于模式和内模式都只有一个，所以模式/内模式映像也**只有一个**。

# 3 第三章

关系是个体之间的关系，联系是实体之间的一对一、一对多、多对多联系。

在数据库领域，关系是一种特殊的表。

## 3.1 关系模型

对关系的描述一般称为关系模式，形如：关系名（属性名1，属性名2......）

**关系模型基础概念**：
1. 元组：关系中的每一行数据称为一个元组或者一条记录。
2. 属性：关系种的每一列称为一个属性，列名就是属性名。
3. 域：属性的取值范围就是域。
4. 码：码也被称为键，指取值具有唯一性的属性，可以唯一确定一条记录的属性，他可以是一个属性也可以由多个属性组成。
5. 主码：一个关系中的所有码构成候选码，为了方便管理，选择**一个**候选码作为主码，主码取值具有唯一性且不可为空。
6. 外码：关系模式中某一个属性不是该关系模式的主码但是是另外一个关系模式的主码，就称其为外码。外码必须和参照主码具有相同的域，取值只能引用参照主码的值或者取null值。

## 3.2 关系的完整性约束

完整性约束是为了保证数据的正确和相容性，对关系模型提出的某些约束条件或者规则。

**完整性约束分类**：
1. 域完整性约束：指属性的取值域的范围约束，包括数据类型、格式、取值范围、是否可为空值等。
2. 实体完整性约束：指所有的关系表都必须具有主码，且每个主码取唯一值和不能为空。
3. 参照完整性约束：指所有外码的取值必须来自于参照主码，或者取空值，不能取不存在的值。
4. 用户定义完整性约束：指针对某一具体关系数据库的约束条件，一般来说就是用户自定义的约束。

## 3.3 关系代数

关系代数是对表中记录的操作，其中，选择、投影、并、差、笛卡尔积是五种基本查询操作。

**关系代数运算符**：
1. 集合运算符：并（⋃）、交（⋂）、差（-）、笛卡尔积（×）。
2. 关系运算符：选择（）、投影（Π）、连接（⋈）、除（÷）。
3. 算术比较符：大于（＞）、大于等于（≥）、小于（＜）、小于等于（≤）、等于（=）、不等于（≠）。
4. 逻辑运算符：与（⋀）、或（⋁）、非（）。
5. 其他运算符：更名（ρ）、赋值（⬅）。

**集合运算**：
1. 并相容性：集合R和S要进行并差交运算，集合R和S必须拥有相同的属性个数。
2. 并：R和S种的所有元组的集合，相同的元组会被消除。
3. 差：集合R种不属于S的元组的集合。
4. 交：集合R和S种共有的元组的集合。由并和差两种操作组合衍生而来。
5. 笛卡尔积：集合R种的元组和S中的元组的所有组合的集合。

**关系运算**：
1. 选择：筛选出集合R中所有符合选择条件的元组。
2. 投影：筛选出集合R中的某些列（属性）而丢弃其他列。
3. 连接：将集合R和S关联起来，且仅保留符合连接条件的元组。是由笛卡尔积和选择两种操作组合衍生而来。
4. 除：集合R中同时包含集合S中相同属性的元组的集合。

**其他运算**：
1. 赋值运算：如果关系表达式的结果没有能够引用的名字，就无法运用于后面的运算，用赋值号给运算结果指定一个关系名。
2. 更名运算：同样输给运算结果取名，还可以给运算结果中的属性名改名。

# 4 第四章

略

# 5 第五章

## 5.1 函数依赖

函数依赖属于数据依赖的一种，当集合R中的两个元组在任意时刻，属性A相同时属性B也相同，则称A**函数决定**B，或称B**函数依赖**A。

**函数依赖的分类**：
1. 完全函数依赖：属性Y函数依赖于属性X，但是属性Y不依赖X的任何真子集。
2. 部分函数依赖：属性Y函数依赖于属性X，而且属性Y依赖于X的真子集。
3. 传递函数依赖：属性Y函数依赖于属性X，属性X不依赖于Y，属性Z依赖于属性Y，则称属性Z（传递）依赖于X。

## 5.2 范式

指规范的表现形式，在关系型数据库中指符合某一种级别的关系模式的集合。

满足第一范式被称为1NF，在此基础上，满足第二范式被称为2NF，以此类推。

六级范式：
1. 第一范式：指一个关系模式种的所有属性都是不可再分的基本数据项。
2. 第二范式：在满足第一范式的基础上，关系模式中的每个非主属性（主码，主键）都完全依赖于主属性。
3. 第三范式：在满足第二范式的基础上，关系模式中的属性不依赖于其他非主属性。
4. BC范式：略
5. 第四范式：略
6. 第五范式：略

## 5.3 关系模式的规范化和反规范化

**规范化**：

关系的规范化越低，越容易出现插入异常、删除异常等情况，因此需要对其进行规范化，将其转换为高级范式。**规范化的过程是对关系进行分解的过程，目的在于减少冗余，消除更新、插入、删除的异常**。需要注意的是并不是越高级的范式越好。

**反规范化**：

正如上述所说，并非越高级的范式越好，因此需要对关系进行反规范化，即对范式降级。**反规范化就是对关系进行合成的过程，其目的在于通过引入部分合理的冗余，提高查询的效率降低查询的难度**。

# 6 第六章
## 6.1 数据库设计的阶段

数据库设计就是在现有的硬件设施、DBMS、系统软件来满足用户的需求转换为有效的数据库模型的过程。

**数据库设计的基本过程**：
1. 需求分析阶段：主要是收集数据和对其进行分析整理。
2. 概念结构设计阶段：负责对用户需求进行分析，将其和数据转换为独立于DBMS的概念模型。
3. 逻辑结构设计阶段：负责将概念模型转换为某个具体DBMS所支持的数据模型，并对其进行优化。
4. 物理结构设计阶段：负责找到合适的物理模型存储逻辑模型。
5. 数据库实施阶段：负责根据逻辑模型和物理模型建立数据库，将数据录入，并进行试运营。
6. 数据库运行与维护阶段：数据库应用程序经过试运营后投入正式使用，在运行过程中不断对其进行优化和迭代。

## 6.2 概念结构设计阶段

该阶段负责将用户需求转换为概念模型，该模型独立于DBMS仅专注于信息的组织结构和处理模式。

采用ER模型方法的概念结构设计通常可分为三步：抽象数据设计局部ER图、集成局部ER图得到全局概念结构、优化全局ER模型。

## 6.3 逻辑结构设计阶段

该阶段负责将概念模型转换为适合DBMS的逻辑结构，分为三步：概念模型转换为关系数据模型、优化数据模型、针对具体应用设计用户外模式。

概念模型转换为关系数据模型就是将ER图表示的实体联系转换成关系模式，通常包含以下两个原则：
1. 每个实体类型转换成一个关系模式，实体的属性就是关系模式的属性，实体的码就是关系模式的主码。
2. 实体间联系根据不同情况有不同的处理，一般来讲需要注意，m:n的联系必须要转换成一个单独的关系模式。

# 7 第七章
## 7.1 事务

**定义**：

事务是用户定义的一个数据操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单元。

**操作**：

事务可以由用户开启，也可以让DBMS自动决定事务是否开启。事务相关的操作：
1. BEGIN TRANSACTION：开启事务。
2. COMMIT：提交事务。
3. ROLLBACK：回滚事务。

**特征（ACID特性）**：

1. 原子性（Atomicity）：指事务的操作要么全部做要么都不做，**不可分割**。
2. 一致性（Consistency）：是指数据库必须从一个一致性转为另一个一致性，不允许部分改变。一致性和原子性紧密相关。
3. 隔离性（Isolation）：指事务不能受到其他事务的干扰，事务之间必须是相互隔离互不干扰的。
4. 持久性（Durability）：也称永久性，事务一旦提交，对数据库的修改就是永久性的。

## 7.2 并发控制

让事务串行执行虽然可以有效保持数据库的一致性，但是效率颇低，于是**为了提高数据库的并行度，避免数据库资源的闲置浪费**，可以让多个事务同时执行，即并发执行。

而在这个过程中，可能存在多个事务同时对一段数据进行读取或改写，出现各种各样的错误，破坏数据库的一致性，因此**保护数据库一致性的这个过程就是并发控制**。

**并发操作引起的问题**：
1. 丢失更新问题：两个事务**同时读取并修改同一段数据**，事务2的提交**覆盖**了事务1的提交，导致事务1的更新丢失。
2. 读“脏”数据问题：事务1对一段数据进行修改后，事务2读取了该段数据，但是由于某种原因，事务1**撤销**了自己的修改操作，导致事务2**之前读取到的数据与现在数据库中的数据不同**，称之为读脏数据。读到脏数据的原因就是读取了未提交事务的数据（或称未提交数据）。
3. 不可重复读问题：事务1读取一段数据后，事务2**修改**了该段数据，此时事务1再读取该段数据却**得到了不同的数据**，读取数据被称为检索，所有又称检索不一致。

**并发控制的手段——封锁技术（或简称锁）**：
1. 封锁（Locking）：就是事务T在操作某一个数据对象之前，向DBMS发送一段请求对操作对象上锁，被上锁的数据对象不能被除事务T以外的事务修改，确保了数据库的一致性。
2. 锁的分类：
   1. 排他锁（简称X锁）：又称写锁，事务T对数据对象上了X锁之后，**只有事务T能够读取和更新该数据对象，其他事务就不能再对该对象上任何锁，也不能读取和更新该数据对象**，直到事务T释放X锁。
   2. 共享锁（简称S锁）：又称读锁，事务T对数据对象上了S锁之后，事务T只能读取该数据对象而不能更新，其他事务**只能对该数据对象上S锁而不能加X锁**，直到事务T释放S锁。注意**上了S锁之后，所有事务都只能读而不能修改**。
3. 封锁协议：
   1. 封锁协议规定了何时上锁，何时释放锁和封锁的时间等，不同等级的封锁协议在一定程度上保证了数据库的一致性避免并发操作引起问题。
   2. 一级封锁协议：在需要**修改数据之前**，必须对数据上**X锁**，**直到事务完成**（事务完成包括commit提交和roolback回滚）。一级协议保证了**不会出现丢失更新的问题**，但是如果只读数据就不用上锁，因此还是可能出现脏数据和不可重复读问题。
   3. 二级封锁协议：在一级封锁协议的基础上，事务在**读取数据之前**，必须对数据上**S锁**，**直到数据读取完成就释放S锁**。二级协议除了保证了不会出现丢失更新问题，还保证**避免了读脏数据的问题**。但是由于数据在读取完成后就释放S锁，这时其他事务就可以修改数据了，所以还是会存在不可重复读的问题。
   4. 三级封锁协议：在一级封锁协议的基础上，事务在**读取数据之前**，必须对数据上**S锁**，**直到事务完成后才释放S锁**。这样就可以保证在事务完成之前，无论读多少次数据都能得到相同的结果，因此**避免了不可重复读的问题**。
   5. 死锁：同操作系统的死锁，两个事务都在等待对方释放上锁的数据，导致两个事务都不能完成。
4. 并发调度的可串行性：见下一节。


## 7.3 并发调度的可串行性

**串行调度**：

即每个事务都顺序执行，这种情况下虽然串行的顺序不一定相同，但**执行结果总是正确的**；

**并发调度**：

区别于串行调度，时刻可以同时执行，这时并行的顺序就可能影响执行结果的正确性。

**并发调度的可串行性**：

指找到并行执行的某个顺序下的结果，与某一串行执行的结果相同，就可以说这个并行执行是正确的。

**二段锁协议**：

是DBMS确保并发调度可串行性的手段，其含义是：将事务分为两个阶段，第一阶段只允许申请封锁，第二阶段只允许释放封锁。

实现了二段锁协议的事务只是具备了可串行化的充分条件而不是必要条件，意思是可串行化的事务同样可以不遵守二段锁协议。

## 7.4 数据恢复

数据库在运行中可能发生各种各样的故障：
1. 事务内部故障：及时回滚事务，并且检查并修复事务内部错误即可。
2. 系统故障：因为各种原因导致系统重启，使部分事务错误提交或未执行导致数据库内部数据错误，需要根据日志还大批量回滚和重做事务来修复。
3. 介质故障：因为外界因素导致数据库严重损坏、数据丢失等问题，需要将数据库恢复到之前的**备份**。
4. 计算机病毒：略

# 10 第十章
## 10.1 安全控制模型

数据库的安全控制包括四个过程，分别是：操作系统安全、SQL Server验证、数据库访问权限、数据库对象访问权限。其中只有最后三个过程由SQL Server负责。

**三个过程**：
1. SQL Server验证：确定用户是否使数据库服务器的合法用户，即拥有登陆账号。
2. 数据库访问权限：确定用户是否是某个数据库的合法用户。
3. 数据库对象访问权限：确定用户是否有合适的操作权限。

## 10.2 身份验证模式

SQL Server提供了两种身份验证模式：

1. windows身份验证模式：即SQL Server通过验证当前用户是否是Windows系统的合法用户来确定是否是数据库服务器的合法用户
2. 混合身份认证模式：即同时允许Windows合法用户和SQL Server单独授权的用户登录到数据库服务器上。

## 10.3 登录名、用户、角色管理

**登录名、用户、角色的区分**：
1. 登录名：数据库访问者需要登录到数据库服务器中，因此需要有一个登录号来通过安全控制的SQL Server验证的过程。
2. 用户：是指对某个数据库具有访问和操作权限的访问者，这个用户身份需要被授予给登录名。
3. 角色：特指具有一系列权限的身份，这个角色身份可以赋予给用户，此时这个用户就具有了该角色所有的权限。

**登录名管理**：
1. 创建：`CREATE LOGIN login_name WITH PASSWORD = '...'`
2. 删除：`DROP LOGIN login_name`

**用户管理**：
1. 创建：`CREATE USER user_name FOR LOGIN login_name`
2. 删除：`DROP USER user_name`

**角色管理**：
1. 创建：`CREATE ROLE role_name`
2. 在创建时赋予用户角色或覆盖其他角色：`CREATE ROLE role_name AUTHORIZATION owner_name`
3. 将某用户添加到角色中：`EXEC sp_addrolemember 'role_name', 'user_name'`
4. 将某用户从角色中删除：`EXEC sp_droprolemember 'role_name', 'user_name'`
5. 删除：`DROP ROLE role_name`
   

## 10.4 权限管理

**权限分类**：
1. 对象权限：即增删改查.
2. 语句权限：即CREATE.
3. 隐含权限：DBMS默认创建的权限。

**权限管理**：
1. 赋予权限：允许用户或角色具有某种操作权。
2. 收回权限：不允许用户或角色具有某种操作权，或者收回之前赋予的权限。
3. 拒绝权限：拒绝用户或角色因为继承而获得某种操作权。

**T-SQL语句**：
1. 赋予：
   1. 对象权限：`GRANT SELECT, DELETE, INSERT, UPDATE ON table_name TO owner_name`
   2. 语句权限：`GRANT CREATE TABLE, CREATE VIEW, CREATE DATABASE TO owner_name`
2. 收回：
   1. 对象权限：`REVOKE SELECT, DELETE, INSERT, UPDATE ON table_name FROM owner_name`
   2. 语句权限：`REVOKE CREATE TABLE, CREATE VIEW, CREATE DATABASE FROM owner_name`
3. 拒绝：
   1. 对象权限：`DENY SELECT, DELETE, INSERT, UPDATE ON table_name TO owner_name`
   2. 语句权限：`DENY  CREATE TABLE, CREATE VIEW, CREATE DATABASE TO owner_name`

# 11 第十一章
## 11.1 备份

**备份的目的**：

为了能够在发生某种故障（见7.4小节）时，及时将已损坏的数据库恢复正常。

**备份的分类**：
1. 完整备份：将所有数据库信息都进行备份，备份下来的时一个完整的数据库。数据库的备份需要时间，在备份中用户同样可以进行操作，且备份会将备份过程中执行的操作记录下来。
2. 差异备份：是对最近一次备份以来发生的数据变化进行备份，它的特点是速度快体积小，通过增加差异备份的次数，可以有效减少数据丢失的风险。
3. 事务日志备份：仅对事务日志进行备份，事务日志中包含了从上一次备份以来所有已经完成的事务。事务日志备份由于只备份事务日志，所以速度更快、占据磁盘空间更小。
4. 需要注意的是，差异备份和事务日志备份尽管都只备份一部分数据加快了备份速度，但是差异备份只保留最近一次修改，事务日志保留了从上一次备份以来的所有事务。

**备份内容**：
1. 系统数据库：记录了重要的系统信息，必须**完整备份**。一旦进行修改，最好立刻备份。
2. 用户数据库：记录了重要的用户数据，必须**完整备份**。可以进行周期性的备份。
3. 事务日志：事务日志体积小，备份时间短，但是**恢复需要的时间长**。

**建立备份**：（其实不重要，强迫症迫使我写了）
1. 完整备份：
   1. 追加式：`BACKUP DATABASE database_name TO DISK='备份设备路径.bak'`
   2. 覆盖式：`BACKUP DATABASE database_name TO DISK='备份设备路径.bak' WITH INIT`
2. 差异备份：
   1. 追加式：`BACKUP DATABASE database_name TO DISK='备份设备路径.bak' WITH DIFFERENTIAL`
   2. 覆盖式：`BACKUP DATABASE database_name TO DISK='备份设备路径.bak' WITH DIFFERENTIAL, INIT`
3. 日志备份：
   1. 截断式：`BACKUP LOG database_name TO DISK='备份设备路径_log'`
   2. 不截断式：`BACKUP LOG database_name TO DISK='备份设备路径_log' WITH NO_TRUNCATE`

## 11.2 备份策略

**策略一：完整备份**

适合于数据量不大，或者不平凡修改的数据库。

**策略二：完整备份+日志备份**

适用于用户不允许丢失太多数据，但又不想经常完整备份的情况。

**策略三：完整备份+差异备份+日志备份**

适用于用户不允许丢失太多数据，但又不想经常完整备份的情况，而且恢复速度比较块的情况。

## 11.3 备份恢复

**恢复顺序（流程）**：
1. 恢复最近的完整数据库备份。
2. 恢复完整备份之后的最近的差异数据库备份。
3. 按事务日志的备份的先后顺序回资完整备份的所有日志备份。

# 12 第十二章

我们可以在数据库里面完成做一些编程相关的事。

## 12.1 变量

**变量分类**：
1. 局部变量：用户自定义的变量，可以用来存储数值或者字符串，以@开头。
2. 全局变量：不能又用户定义的变量，是DBMS自带的变量，以@@开头，一般存有某些特定的值。

**变量声明和赋值**：
1. 声明：`DECLARE @local_variable_name datatype`
2. 赋值：`SET @local_variable_name = expression` 或者 `SELECT @local_variable_name = expression`

**运算符**:

略

## 12.2 流程控制

**选择判断**：

`IF...ELSE` 和 `CASE...ELSE`

**循环**：

`WHILE...CONTINUE...BREAK`

**分段符**：

`BEGIN...END`

## 12.3 存储过程

**存储过程定义**：

是为了实现某一功能的语句集合体，这些语句集合为一个完整单元并给他取一个名字。

**优点**：
1. 存储编译结果，执行速度快、效率高。
2. 可被多次调用。
3. 存储过程存储在数据库中，可以方便的被用户调用。
4. 存储过程可以接收传出数据，可以被嵌套使用。
5. 开发者可以不必在客户端编写大量代码。

**创建**：
1. 不带参数：
   ``` SQL
   CREATE PROCEDURE name
   AS
   (...) 
   ```
2. 带参数：
   ``` SQL
   CREATE PROCEDURE name
   @v1 datatype,
   @v2 datatype,
   @result datatype OUTPUT
   AS
   (...) 
   ```

**删除**：

`DROP PROCEDURE name`

**执行**：

`EXEC name 'v1', 'v2', @answer OUTPUT`

## 12.4 触发器

**触发器定义**：

触发器是在对表进行插入、更新或者删除操作时自动执行的**存储过程**，触发器时一种高级约束。

**触发器类型**：
1. AFTER触发器：在执行INSERT、UPDATE、DELETE**之后**执行的触发器。
2. INSTEAD OF触发器：在执行指定操作**之前**触发，**不执行指定操作而是执行INSTEAD OF触发器中定义的操作**。

**inserted和deleted表**：
1. 这两张表是在触发器触发时临时创建的两张表，只可读不可写，触发器执行完之后自动删除。
2. inserted表：临时保存了插入或者更新之后的记录行。
3. deleted表：临时保存了删除或者更新之前的记录行。
4. 可以在触发器内查询这两张表来决定是否进行某种操作。

**创建**：
``` SQL
CREATE TRIGGER trigger_name
ON table_name
FOR [DELEtE, INSERT, UPDATE]
AS
(...)
```

**删除**：

`DROP TRIGGER trigger_name` 大概.0